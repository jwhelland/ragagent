# Entity Deduplication & Streamlining Strategies

**Date:** 2025-12-28
**Status:** Proposed
**Goal:** Streamline the entity curation process when re-ingesting documents by handling candidates that already match approved entities.

---

## Strategy 1: Pipeline-Level Pre-Resolution (Optional)

This strategy intervenes at the earliest possible stage: during the extraction and discovery phase.

### Concept
When the `DiscoveryPipeline` runs, it can optionally load the set of already normalized/approved entities. As new entity candidates are generated by the LLM or spaCy, the system checks them against this known set. If an exact match (Name + Type) is found, the candidate is automatically treated as "resolved" and does not enter the manual review queue.

### Implementation Plan

1.  **CLI Argument**
    *   Update `scripts/run_discovery.py` (and `ragagent-discover` entry point).
    *   Add a flag: `--resolve-existing / --no-resolve-existing` (Default: `False` for safety, or `True` if confident).

2.  **Entity Cache Mechanism**
    *   Modify `src/pipeline/discovery_pipeline.py`.
    *   Add a method `load_known_entities()` that reads from `data/normalization/` (and/or Neo4j) to build a quick lookup set: `Set[Tuple[str, str]]` (Name, Type).

3.  **Filtration Logic**
    *   In the `run()` or `process_batch()` method of the pipeline:
        ```python
        if self.resolve_existing:
            # Check if candidate matches known entity
            if (candidate.name, candidate.type) in known_entities:
                # Log as auto-resolved
                logger.info(f"Auto-resolving known entity: {candidate.name}")
                # Optionally: Write to a separate 'auto_resolved.jsonl' for audit
                continue # Skip writing to 'pending' queue
        ```

4.  **Output Handling**
    *   Ensure "skipped" entities are still accounted for in term frequency/document linkage if that data is needed immediately, or assume the `IngestionPipeline` (Neo4j linkage) handles the actual graph connection later. *Note: Since Discovery is usually just about finding *new* things, skipping them here is generally safe.*

### Deliverables
*   Updated `DiscoveryPipeline` class.
*   New CLI flag in `ragagent-discover`.
*   Unit test ensuring known entities are skipped when flag is active.

---

## Strategy 2: Batch Auto-Approve Command

This strategy provides a safe, user-initiated "cleanup" action that runs after discovery but before manual review.

### Concept
A standalone command or flag that scans the `data/entities/*.jsonl` (pending candidates) and compares them against `data/normalization/` (approved entities). Exact matches are automatically moved from "Pending" to "Approved" status (or simply removed from Pending if they are redundant duplicates).

### Implementation Plan

1.  **New Script/Command**
    *   Create logic in `src/curation/batch_operations.py`.
    *   Function: `auto_approve_exact_matches(pending_dir, normalization_dir)`.

2.  **Matching Logic**
    *   Load all normalized entities into a `ReferenceMap`.
    *   Iterate through all JSONL files in `data/entities/`.
    *   For each candidate:
        *   **Exact Match:** Name (case-insensitive or exact, based on config) and Type match a normalized entry.
        *   **Action:**
            1.  **Graph Update:** Call `merge_candidate_into_entity` (updates Graph: relationships, docs, mentions, chunks).
            2.  **Archive:** Move the candidate entry from the "Pending" file to a corresponding "Processed" file (e.g., `data/entities/processed/YYYYMMDD_auto_approved.jsonl`). **DO NOT DELETE** the data. This preserves the raw extraction history for potential graph rebuilds.
            3.  (Optional) Update the "Frequency" count of the existing normalized entity if tracking global stats.
            4.  Log the action to an audit file (e.g., `logs/auto_approvals.log`).

    *   **Safety Constraints (Gotchas):**
        *   **Disable Undo Stack:** The `EntityCurationService` normally tracks every change. For batch operations (potentially 1000s of items), this will crash the TUI's undo system. The batch command must initialize the service with `undo_stack_path=None` or a dummy path, effectively disabling granular undo.
        *   **Skip Ambiguous Candidates:** If `candidate.conflicting_types` is non-empty, **SKIP** auto-approval. These indicate the LLM was unsure, and even if the primary type matches, it requires human eyes.
        *   **Exclusive Access:** Ensure this script uses a file lock or documents that it must not run concurrently with the TUI or Ingestion Pipeline to avoid race conditions on JSONL files.

    *   **Handling Cross-Document Mentions (CRITICAL):**
        *   When a candidate from `doc_new` matches an existing entity `E` (originally from `doc_old`):
        *   **Do Not Discard:** The system must not simply discard the candidate as a "duplicate".
        *   **Merge Logic:**
            1.  **Graph Update:** Explicitly create a `MENTIONED_IN` relationship between Entity `E` and Document `doc_new` in Neo4j.
            2.  **Metadata Update:** Update `E.source_documents` to include `doc_new`.
            3.  **Mentions:** Increment `E.mention_count` by `candidate.mention_count`.
            4.  **Chunks:** Merge `candidate.chunk_ids` into `E.properties.chunk_ids`.
        *   **Implementation:** Use `EntityCurationService.merge_candidate_into_entity()` (or a batch-optimized equivalent) rather than simple deletion. This ensures `upsert_entity` is called, which handles the graph edge creation.

3.  **CLI Integration**
    *   Update `scripts/review_entities.py` (or create `scripts/auto_approve.py`).
    *   Add command: `uv run ragagent-review --auto-approve-existing`.
    *   Add a `--dry-run` flag to preview how many items would be removed/approved.

### Deliverables
*   `batch_operations.py` extension.
*   CLI command with `--dry-run` safety.
*   Audit logging for approved items.

---

## Strategy 3: TUI "Smart Merge" View

This strategy integrates with the interactive Terminal User Interface (TUI) to give the user final say but with drastically reduced friction.

### Concept
Instead of presenting candidates one-by-one, the TUI detects candidates that look like they match existing entities. It groups these into a specific "Fast Track" or "Suggested Merge" view.

### Implementation Plan

1.  **Backend Detection**
    *   In `src/curation/review_interface.py` (or the TUI controller), pre-scan the loaded candidates.
    *   Separate the queue into two lists: `unknown_candidates` and `potential_matches`.
    *   `potential_matches` contains candidates where `candidate.name` equals `existing.name` (exact) or `fuzz.ratio > 95` (fuzzy).

2.  **UI Components**
    *   Create a new Textual Screen or Widget: `SmartMergeView`.
    *   Display:
        *   Left Column: Candidate Name/Type/Context.
        *   Right Column: Existing Entity it matches.
        *   Center: "Match Confidence" (e.g., "Exact Match", "Fuzzy 98%").

3.  **Bulk Actions**
    *   Bind key `A` to "Approve All Exact Matches".
    *   Bind key `Space` to "Approve Selected".
    *   Bind key `D` to "Deny/Treat as New" (for false positives, e.g., distinct entities with same name).

4.  **Workflow Update**
    *   When `ragagent-review-interactive` starts:
        *   If `potential_matches > 0`, prompt user: "Found X candidates matching existing entities. Review these first? [Y/n]".

### Deliverables
*   Updated TUI State Management (`ReviewState`).
*   New `SmartMerge` screen in the Textual app.
*   Logic to route "Matched" candidates to this screen.

---

## Summary of Recommendation

1.  **Phase 1 (Immediate):** Implement **Strategy 2 (Batch Command)**. It is the safest, easiest to debug, and solves the bulk of the pain point without complex UI work or modifying the ingestion pipeline logic.
2.  **Phase 2:** Implement **Strategy 1 (Pipeline Flag)**. Once Strategy 2 is proven, move this logic "upstream" to prevent the data from being generated in the first place.
3.  **Phase 3:** Implement **Strategy 3 (TUI)** if fuzzy matching/disambiguation remains a bottleneck.

---

## Code Review Findings (2025-12-28)

### Critical Pre-Implementation Fix Required

**Issue:** `merge_candidate_into_entity()` does NOT create MENTIONED_IN relationships for cross-document mentions.

**Location:** `src/curation/entity_approval.py:462`

**Status:** ✅ **FIXED** (2025-12-28)

**The Problem:** `update_entity()` only does `SET n += $properties` — it does NOT create MENTIONED_IN edges. This meant when merging a candidate from `doc_new` into entity `E` from `doc_old`, the graph would NOT have a MENTIONED_IN relationship to `doc_new`.

**The Fix Applied:**
1. Added `create_mentioned_in_relationships(entity_id, document_ids)` method to `Neo4jManager` (`neo4j_manager.py:1069-1109`)
2. Updated `merge_candidate_into_entity()` to call this method for new documents (`entity_approval.py:464-468`)
3. Added unit test `test_merge_candidate_into_entity_creates_mentioned_in_relationships()` to verify the fix

```python
# After updating properties, create MENTIONED_IN for new source documents:
docs_to_link = new_docs - current_docs
if docs_to_link:
    self.manager.create_mentioned_in_relationships(entity_id, list(docs_to_link))
```

---

### Additional Gotchas Identified

| # | Issue | Impact | Mitigation |
|---|-------|--------|------------|
| 1 | **Source of truth mismatch** | NormalizationTable (file-based) can diverge from Neo4j | Query Neo4j as authoritative source for approved entities |
| 2 | **Alias matching missing** | "BMS" won't match "Battery Management System" in aliases | Build lookup including ALL aliases + canonical names |
| 3 | **Case sensitivity undefined** | Inconsistent matching behavior | Normalize to lowercase before comparison |
| 4 | **No file locking** | Race conditions with TUI/ingestion | Document as user responsibility (see below) |
| 5 | **Undo stack explosion** | 1000 candidates = 1000 disk writes | Pass `undo_stack_path=None` for batch operations |
| 6 | **Audit trail fragmentation** | Multiple log locations proposed | Use existing `CurationAuditTrail` class |
| 7 | **No crash recovery** | Partial failures leave inconsistent state | Document that interrupted batches need manual review |
| 8 | **O(n²) fuzzy matching** | Performance degradation at scale | Use exact match only for batch; reserve fuzzy for TUI |

---

### Design Decisions (Confirmed)

1. **Alias matching scope:** Include aliases — match if candidate name/aliases overlap with existing name/aliases
2. **Type strictness:** Strict match only — auto-approve only if types match exactly; type mismatches go to manual review
3. **Concurrency:** Document only — user responsibility to not run concurrently with TUI/ingestion

---

### Amendments to Strategies

#### Strategy 1 Amendment: Entity Cache

Replace the lookup set approach with alias-aware matching:
```python
def load_known_entities(self) -> Dict[Tuple[str, str], str]:
    """Load (normalized_name, type) → entity_id mapping from Neo4j."""
    query = """
    MATCH (e) WHERE any(label IN labels(e) WHERE label IN $entity_types)
    AND e.status = 'approved'
    RETURN e.id, e.canonical_name, e.aliases, labels(e) as types
    """
    lookup = {}
    for record in results:
        entity_type = record["types"][0]  # Primary type
        entity_id = record["id"]
        # Add canonical name
        lookup[(normalize(record["canonical_name"]), entity_type)] = entity_id
        # Add all aliases
        for alias in record.get("aliases", []):
            lookup[(normalize(alias), entity_type)] = entity_id
    return lookup
```

#### Strategy 2 Amendment: Matching Logic

```markdown
**Match Scope:**
- Build lookup as `Dict[Tuple[str, str], str]` mapping `(normalized_name, type)` → `entity_id`
- Include ALL aliases: for each approved entity, add entries for canonical_name AND all aliases
- Normalize names (lowercase, strip whitespace) before comparison
- **Type must match exactly** — skip if candidate.type != existing.type

**Alias Resolution:**
- If `candidate.canonical_name` matches existing alias → merge into that entity
- If any `candidate.alias` matches existing canonical_name → merge into that entity
- If multiple entities match (ambiguous) → skip, flag for manual review

**Concurrency Documentation (CLI help text):**
> WARNING: This command must NOT run concurrently with ragagent-review-interactive,
> ragagent-ingest, or other batch-approve instances. Concurrent execution may cause
> data corruption.
```

#### Strategy 3 Amendment: Performance

```markdown
**Approved Entity Caching:**
- Load all approved entities into memory at TUI startup (in `ReviewApp.__init__()`)
- Use exact match first (O(1) lookup), then fuzzy match for display only
- Fuzzy matching is O(n×m); limit to interactive context where N is small
```

---

### Existing Infrastructure (What Already Works)

| Component | Location | Status |
|-----------|----------|--------|
| `merge_candidate_into_entity()` | entity_approval.py:423 | ✅ Exists (needs MENTIONED_IN fix) |
| `BatchCurationService` | batch_operations.py | ✅ Exists |
| Checkpoint/rollback pattern | batch_operations.py:87,122,160 | ✅ Exists |
| `CandidateStatus.MERGED_INTO_ENTITY` | schemas.py:57 | ✅ Exists |
| `CurationAuditTrail` | entity_approval.py:90-111 | ✅ Exists |
| CLI `batch-approve` command | review_interface.py:547 | ✅ Exists (threshold-based) |
| TUI `DuplicateSuggestionsPanel` | widgets/duplicate_suggestions.py | ✅ Exists (candidates only) |

### What Needs Building

| Component | Effort | Status |
|-----------|--------|--------|
| Fix MENTIONED_IN gap in merge_candidate_into_entity | Low | ✅ Done |
| Alias-aware lookup builder | Low | ✅ Done (2025-12-28) |
| `auto-approve-existing` CLI command | Medium | ✅ Done (2025-12-28) |
| TUI check vs approved entities (TODO at line 113) | Medium | Pending |
| SmartMergeView widget | High | Pending |

---

## Implementation Notes (2025-12-28)

### Strategy 2 Implementation Complete

**Files Modified:**
- `src/curation/batch_operations.py` - Added `ApprovedEntityLookup` class, `build_approved_entity_lookup()`, `AutoApproveMatchPreview` model, and `auto_approve_existing_matches()` method
- `src/curation/review_interface.py` - Added `auto-approve-existing` CLI command
- `tests/test_curation/test_batch_operations.py` - Added 17 new tests for the functionality

**Usage:**
```bash
# Preview what would be merged (dry-run is default for safety)
uv run ragagent-review auto-approve-existing

# Execute the merges
uv run ragagent-review auto-approve-existing --no-dry-run

# Process a specific number of candidates
uv run ragagent-review auto-approve-existing --limit 500 --no-dry-run
```

**Key Features:**
- Alias-aware matching: Matches candidate names/aliases against approved entity names/aliases
- Type strictness: Only merges when entity types match exactly
- Safety: Skips candidates with `conflicting_types` (requires human review)
- Dry-run default: Must explicitly use `--no-dry-run` to execute
- Checkpoint/rollback: Uses existing undo infrastructure for atomic operations
